#!/bin/sh
#
# sigmet_ppi_ps --
#	Render a PPI sweep with Postscript.
#
# Usage:
#	sigmet_ppi_ps data_types sweep_angles raw_fl
#
# where:
#	data_types	- list of desired data types (e.g. DB_DBZ, DB_ZDR).
#			  If a data type is not in the volume, script will
#			  quietly skip it.
#	sweep_angles	- list of desired sweep angles, in degrees.
#			  For each angle, script will generate an image for the
#			  sweep whose sweep angle is closest to the given angle.
#			  Number of sweeps may be less then the number of values
#			  in sweep_angles.
#
# The following special commands must be in the current path
#	proj		- convert lat-lon's to map coordinates
#	geog		- trekix
#	utm_zone	- trekix
#
# Optional environment variables:
#	SIGMET_RAW_COLORS		- path to directory with color table
#					  files. For each data type DB_XXX
#					  this directory must contain a file
#					  named DB_XXX.clrs with output from
#					  the raster_clrs program appropriate
#					  for the data type. Defaults to
#					  current working directory.
#	SIGMET_RAW_IMG_SZ		- width of the postscript display area,
#					  in points.
#	SIGMET_SEM_PROC			- identifier for a semaphore assumed to
#					  be decremented by the number of
#					  megabytes this process will need to
#					  store the volume. When this process
#					  terminates, the associated semaphore
#					  will be incremented with a call to
#					  clsem.
#	SIGMET_RAW_VOL_SZ		- estimated number of megabytes this
#					  process will need to store the volume,
#					  needed by clsem if SIGMET_SEM_PROC
#					  is set.
#	SIGMET_CORRECTIONS		- name of a file with correction
#					  specifiers.  Script sigmet_correct
#					  should be in current path. See
#					  sigmet_correct for format.
#
# This script will create a directory in the current directory named for
# raw_fl. The images and xml metadata files will be in this new directory.
#
# Upon successful exit, the script will print the name of the new directory.
#
# Copyright (c) 2011, Gordon D. Carrie. All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 
#     * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Please send feedback to dev0@trekix.net

# Parse command line
if [ $# -ne 3 ]
then
    echo Usage: $0 data_types sweep_angles raw_file
    exit 1
fi
data_types=$1
sweep_angles=$2
raw_fl=$3

# Clean up on exit
cleanup() {
    if test $SIGMET_SEM_PROC
    then
	clsem 1 $SIGMET_SEM_PROC 2> /dev/null
    fi
    if test "$SIGMET_RAW_VOL_SZ" -a "$SIGMET_SEM_MEM"
    then
	clsem $SIGMET_RAW_VOL_SZ $SIGMET_SEM_MEM 2> /dev/null
    fi
    sigmet_raw unload -f $sock 2> /dev/null
}
trap " cleanup; " EXIT
trap " echo $0 exiting on TERM signal;exit 1; " TERM
trap " echo $0 exiting on KILL signal;exit 1; " KILL
trap " echo $0 exiting on QUIT signal;exit 1; " QUIT
trap " echo $0 exiting on INT signal;exit 1; " INT
trap " echo $0 exiting on HUP signal;exit 1; " HUP

# This convenience function evaluates an expression with bc and formats result
bcalc() {
    if test $2
    then
	printf "$2\n" `echo "$1" | bc -l`
    else
	echo "$1" | bc -l
    fi
}

# geog program needs this
export ANGLE_UNIT='DEGREE'

# KML format
kml_tmpl='<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <GroundOverlay>
    <name>%s sweep</name>
    <description>
%s at %s %s Field: %s. %04.1f degrees
</description>
    <LatLonBox>
      <north>%f</north>
      <south>%f</south>
      <west>%f</west>
      <east>%f</east>
    </LatLonBox>
    <Icon>
      %s
    </Icon>
  </GroundOverlay>
</kml>'

# Load the volume into a sigmet_raw daemon and apply corrections.
echo Loading $raw_fl
base_nm=`basename $raw_fl | sed -e 's/\.gz$//' -e 's/\.bz2$//'`
sock=`echo $raw_fl | sed -e 's!.*/!!' -e 's/\.gz$//' -e 's/\.bz2$//'`
sigmet_raw load $raw_fl $sock || exit 1
if test $SIGMET_CORRECTIONS
then
    sigmet_correct $SIGMET_CORRECTIONS || exit 1
fi

# Get volume header values
# ray_len_m = ray length in meters
# ray_len_deg = ray length in great circle degrees. Assume 1' = 1852 m.
echo Getting volume information
hdr='radar_lon|radar_lat|num_bins|range_bin0|bin_step'
for l in `sigmet_raw vol_hdr $sock | egrep $hdr`
do
    eval $l
done
ray_len_m=`bcalc "($range_bin0 + $num_bins * $bin_step) / 100.0"`
ray_len_deg=`bcalc "($range_bin0 + $num_bins * $bin_step) \
	/ 100.0 / 1852.0 / 60.0"`

# Options to proj command
zn=`utm_zone $radar_lon`
proj_opt="+proj=utm +zone=$zn +ellps=WGS84 +datum=WGS84 +units=m +no_defs"

# Determine coordinates of display area in map coordinates
echo Configuring image
eval `awk 'BEGIN {for (dir = 0; dir < 360.0; dir += 1.0) {print dir}}' \
    | while read dir
    do
	geog step $radar_lon $radar_lat $dir $ray_len_deg
    done \
    | proj $proj_opt \
    | awk '
	BEGIN {
	    xmin = 1.0e12;
	    xmax = -xmin;
	    ymin = 1.0e12;
	    ymax = -ymin;
	}
	{
	    x = $1;
	    y = $2;
	    xmin = (x < xmin) ? x : xmin;
	    xmax = (x > xmax) ? x : xmax;
	    ymin = (y < ymin) ? y : ymin;
	    ymax = (y > ymax) ? y : ymax;
	}
	END {
	    printf "xmin=%f\nxmax=%f\nymin=%f\nymax=%f\n",
		    xmin, xmax, ymin, ymax;
	}
    '`

img_width_m=`bcalc "$xmax - $xmin"`
img_height_m=`bcalc "$ymax - $ymin"`
img_width_pt=${SIGMET_RAW_IMG_SZ:-"800"}
pt_per_m=`bcalc "$img_width_pt / ($xmax - $xmin)"`
img_height_pt=`bcalc "($ymax - $ymin) * $pt_per_m"`

color_dir=${SIGMET_RAW_COLORS:-"."}

# Print Postscript code for PPI image
for data_type in $data_types
do
    color_fl=${color_dir}/${data_type}.clrs
    for sweep_angle in $sweep_angles
    do
	sweep=`sigmet_raw near_sweep $sweep_angle $sock`
	if test $sweep
	then
	    vol_swp_angl=`sigmet_raw sweep_headers $sock \
			 | awk '/sweep +'$sweep' / {print $5}'`
	    img_nm=`printf '%s_%s_%05.1f.ps' $base_nm $data_type $vol_swp_angl`
	fi
	echo Creating $img_nm
	{
	    printf '%%!PS-Adobe-3.0 EPSF-3.0\n'
	    printf '%%%%BoundingBox: 0 0 %f %f\n' $img_width_pt $img_height_pt
	    printf '%%%%EndComments\n'
	    printf '/m { moveto } def\n'
	    printf '/l { lineto } def\n'
	    printf '/cf { closepath fill } def\n'
	    printf '%%%%EndProlog\n'
	    egrep '[0-9.e+-]+ #[0-9A-Fa-f]+ [0-9.e+-]+' $color_fl \
	    | while read min color max
	    do
		# Convert #rrggbb to red green blue
		eval `echo $color | sed \
			's/#\(..\)\(..\)\(..\)/red=0x\1;green=0x\2;blue=0x\3/'`
		if ! test $red || ! test $green || ! test $blue
		then
		    echo Could not get red from $color
		    exit 1
		fi
		red=`printf '%f / 255.0\n' $red | bc -l`
		green=`printf '%f / 255.0\n' $green | bc -l`
		blue=`printf '%f / 255.0\n' $blue | bc -l`

		printf '%f %f %f setrgbcolor\n' $red $green $blue
		sigmet_raw outlines -b $data_type $sweep $min $max - $sock \
		| proj -i $proj_opt \
		| awk -v xmin=$xmin -v ymin=$ymin -v pt_per_m=$pt_per_m '
		    {
			printf "%.0f %.0f m\n",
				($1 - xmin) * pt_per_m, ($2 - ymin) * pt_per_m;
			getline
			printf "%.0f %.0f l\n", 
				($1 - xmin) * pt_per_m, ($2 - ymin) * pt_per_m;
			getline
			printf "%.0f %.0f l\n", 
				($1 - xmin) * pt_per_m, ($2 - ymin) * pt_per_m;
			getline
			printf "%.0f %.0f l\n", 
				($1 - xmin) * pt_per_m, ($2 - ymin) * pt_per_m;
			printf "cf\n"
		    }'
	    done
	    printf "%%%%EOF\n"
	} > $img_nm

	# Create kml file
	kml_nm=`printf '%s_%s_%05.1f.kml' $base_nm $data_type $vol_swp_angl`
	if ! test -f $kml_nm
	then
	    echo Creating kml file
	    proj_opt="$proj_opt -f %.5f"
	    site_name=`sigmet_raw volume_headers $sock \
		    | awk -F \| '/su_site_name/ {print $1}'`
	    sweep_time="`sigmet_raw sweep_headers $sock \
		    | awk '/sweep +'$sweep' / {print $3 " " $4}'`"
	    eval `echo $xmin $ymin | invproj $proj_opt \
		    | awk '{printf "west=%f\nsouth=%f\n", $1, $2}'`
	    eval `echo $xmax $ymax | invproj $proj_opt \
		    | awk '{printf "east=%f\nnorth=%f\n", $1, $2}'`
	    printf "$kml_tmpl" $site_name $site_name $sweep_time $data_type \
		    $vol_swp_angl $north $south $west $east $img_nm > $kml_nm
	fi
    done
done
exit 0
